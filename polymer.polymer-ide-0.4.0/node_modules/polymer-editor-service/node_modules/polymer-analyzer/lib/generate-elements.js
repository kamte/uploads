/**
 * @license
 * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const jsonschema = require("jsonschema");
const pathLib = require("path");
function generateElementMetadata(features, packagePath) {
    const elements = features.filter((f) => f.kinds.has('element'));
    const mixins = features.filter((f) => f.kinds.has('element-mixin'));
    const metadata = {
        schema_version: '1.0.0',
    };
    if (elements.length > 0) {
        metadata.elements =
            elements.map((e) => serializeElement(e, packagePath));
    }
    if (mixins.length > 0) {
        metadata.mixins = mixins.map((m) => serializeElementMixin(m, packagePath));
    }
    return metadata;
}
exports.generateElementMetadata = generateElementMetadata;
const validator = new jsonschema.Validator();
const schema = JSON.parse(fs.readFileSync(pathLib.join(__dirname, 'analysis.schema.json'), 'utf-8'));
class ValidationError extends Error {
    constructor(result) {
        const message = `Unable to validate serialized Polymer analysis. ` +
            `Got ${result.errors.length} errors: ` +
            `${result.errors.map((err) => '    ' + (err.message || err))
                .join('\n')}`;
        super(message);
        this.errors = result.errors;
    }
}
exports.ValidationError = ValidationError;
/**
 * Throws if the given object isn't a valid AnalyzedPackage according to
 * the JSON schema.
 */
function validateElements(analyzedPackage) {
    const result = validator.validate(analyzedPackage, schema);
    if (result.throwError) {
        throw result.throwError;
    }
    if (result.errors.length > 0) {
        throw new ValidationError(result);
    }
    if (!/^1\.\d+\.\d+$/.test(analyzedPackage.schema_version)) {
        throw new Error(`Invalid schema_version in AnalyzedPackage. ` +
            `Expected 1.x.x, got ${analyzedPackage.schema_version}`);
    }
}
exports.validateElements = validateElements;
function serializeElement(element, packagePath) {
    const metadata = serializeElementLike(element, packagePath);
    metadata.tagname = element.tagName;
    metadata.superclass = 'HTMLElement';
    return metadata;
}
function serializeElementMixin(mixin, packagePath) {
    const metadata = serializeElementLike(mixin, packagePath);
    metadata.name = mixin.name;
    return metadata;
}
function serializeElementLike(elementOrMixin, packagePath) {
    const path = elementOrMixin.sourceRange.file;
    const packageRelativePath = pathLib.relative(packagePath, elementOrMixin.sourceRange.file);
    const attributes = elementOrMixin.attributes.map((a) => serializeAttribute(elementOrMixin, path, a));
    const properties = elementOrMixin.properties
        .filter((p) => !p.private &&
        // Blacklist functions until we figure out what to do.
        p.type !== 'Function')
        .map((p) => serializeProperty(elementOrMixin, path, p));
    const events = elementOrMixin.events.map((e) => ({
        name: e.name,
        description: e.description || '',
        type: 'CustomEvent',
        metadata: elementOrMixin.emitEventMetadata(e)
    }));
    return {
        description: elementOrMixin.description || '',
        path: packageRelativePath,
        attributes: attributes,
        properties: properties,
        styling: {
            cssVariables: [],
            selectors: [],
        },
        demos: (elementOrMixin.demos || []).map((d) => d.path),
        slots: elementOrMixin.slots.map((s) => {
            return { description: '', name: s.name, range: s.range };
        }),
        events: events,
        metadata: elementOrMixin.emitMetadata(),
        sourceRange: resolveSourceRangePath(path, elementOrMixin.sourceRange),
    };
}
function serializeProperty(resolvedElement, elementPath, resolvedProperty) {
    const property = {
        name: resolvedProperty.name,
        type: resolvedProperty.type || '?',
        description: resolvedProperty.description || '',
        sourceRange: resolveSourceRangePath(elementPath, resolvedProperty.sourceRange)
    };
    if (resolvedProperty.default) {
        property.defaultValue = resolvedProperty.default;
    }
    property.metadata = resolvedElement.emitPropertyMetadata(resolvedProperty);
    return property;
}
function serializeAttribute(resolvedElement, elementPath, resolvedAttribute) {
    const attribute = {
        name: resolvedAttribute.name,
        description: resolvedAttribute.description || '',
        sourceRange: resolveSourceRangePath(elementPath, resolvedAttribute.sourceRange)
    };
    if (resolvedAttribute.type) {
        attribute.type = resolvedAttribute.type;
    }
    attribute.metadata = resolvedElement.emitAttributeMetadata(resolvedAttribute);
    return attribute;
}
function resolveSourceRangePath(elementPath, sourceRange) {
    if (!sourceRange) {
        return;
    }
    if (!sourceRange.file) {
        return sourceRange;
    }
    if (elementPath === sourceRange.file) {
        return { start: sourceRange.start, end: sourceRange.end };
    }
    // The source location's path is relative to file resolver's base, so first
    // we need to make it relative to the element.
    const filePath = pathLib.relative(pathLib.dirname(elementPath), sourceRange.file);
    return { file: filePath, start: sourceRange.start, end: sourceRange.end };
}

//# sourceMappingURL=generate-elements.js.map
