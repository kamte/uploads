"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const model_1 = require("../model/model");
const polymer_element_1 = require("./polymer-element");
class ScannedPolymerElementMixin extends model_1.ScannedElementMixin {
    constructor(options) {
        super();
        this.properties = [];
        this.observers = [];
        this.listeners = [];
        this.behaviorAssignments = [];
        // Indicates if an element is a pseudo element
        this.pseudo = false;
        // TODO(justinfagnani): fix this constructor to not be crazy, or remove
        // class altogether.
        const optionsCopy = Object.assign({}, options);
        delete optionsCopy.properties;
        Object.assign(this, optionsCopy);
        if (options && options.properties) {
            options.properties.forEach((p) => this.addProperty(p));
        }
    }
    addProperty(prop) {
        polymer_element_1.addProperty(this, prop);
    }
    resolve(_document) {
        const element = new PolymerElementMixin();
        Object.assign(element, this);
        return element;
    }
}
exports.ScannedPolymerElementMixin = ScannedPolymerElementMixin;
class PolymerElementMixin extends model_1.ElementMixin {
    constructor() {
        super();
        this.localIds = [];
        this.kinds = new Set(['element-mixin', 'polymer-element-mixin']);
        this.behaviorAssignments = [];
    }
    emitPropertyMetadata(property) {
        const polymerMetadata = {};
        const polymerMetadataFields = ['notify', 'observer', 'readOnly'];
        for (const field of polymerMetadataFields) {
            if (field in property) {
                polymerMetadata[field] = property[field];
            }
        }
        return { polymer: polymerMetadata };
    }
}
exports.PolymerElementMixin = PolymerElementMixin;

//# sourceMappingURL=polymer-element-mixin.js.map
