/**
 * @license
 * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const astValue = require("../javascript/ast-value");
const esutil = require("../javascript/esutil");
const warning_1 = require("../warning/warning");
const js_utils_1 = require("./js-utils");
function analyzeProperties(node, document) {
    const analyzedProps = [];
    if (node.type !== 'ObjectExpression') {
        return analyzedProps;
    }
    for (const property of node.properties) {
        const prop = js_utils_1.toScannedPolymerProperty(property, document.sourceRangeForNode(property));
        prop.published = true;
        let isComputed = false;
        if (property.value.type === 'Identifier') {
            prop.type = property.value.name;
        }
        else if (property.value.type !== 'ObjectExpression') {
            continue;
        }
        else {
            /**
             * Parse the expression inside a property object block. e.g.
             * property: {
             *   key: {
             *     type: String,
             *     notify: true,
             *     value: -1,
             *     readOnly: true,
             *     reflectToAttribute: true
             *   }
             * }
             */
            for (const propertyArg of property.value.properties) {
                const propertyKey = esutil.objectKeyToString(propertyArg.key);
                switch (propertyKey) {
                    case 'type':
                        prop.type = esutil.objectKeyToString(propertyArg.value);
                        if (prop.type === undefined) {
                            prop.warnings.push({
                                code: 'invalid-property-type',
                                message: 'Invalid type in property object.',
                                severity: warning_1.Severity.ERROR,
                                sourceRange: document.sourceRangeForNode(propertyArg)
                            });
                        }
                        break;
                    case 'notify':
                        prop.notify = !!astValue.expressionToValue(propertyArg.value);
                        break;
                    case 'observer':
                        const val = astValue.expressionToValue(propertyArg.value);
                        prop.observerNode = propertyArg.value;
                        if (val === undefined) {
                            prop.observer = astValue.CANT_CONVERT;
                        }
                        else {
                            prop.observer = JSON.stringify(val);
                        }
                        break;
                    case 'readOnly':
                        prop.readOnly = !!astValue.expressionToValue(propertyArg.value);
                        break;
                    case 'reflectToAttribute':
                        prop.reflectToAttribute = !!astValue.expressionToValue(propertyArg);
                        break;
                    case 'computed':
                        isComputed = true;
                        break;
                    case 'value':
                        prop.default =
                            JSON.stringify(astValue.expressionToValue(propertyArg.value));
                        break;
                    default:
                        break;
                }
            }
        }
        if (isComputed) {
            prop.readOnly = true;
        }
        prop.type = esutil.CLOSURE_CONSTRUCTOR_MAP[prop.type] || prop.type;
        if (!prop.type) {
            prop.warnings.push({
                code: 'no-type-for-property',
                message: 'Unable to determine type for property.',
                severity: warning_1.Severity.WARNING,
                sourceRange: document.sourceRangeForNode(property)
            });
        }
        analyzedProps.push(prop);
    }
    return analyzedProps;
}
exports.analyzeProperties = analyzeProperties;
;

//# sourceMappingURL=analyze-properties.js.map
