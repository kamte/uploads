/* --------------------------------------------------------------------------------------------
 * Copyright multiple authors.
 * See ../LICENSE for license information.
 ------------------------------------------------------------------------------------------
 */
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Implements the [language server protocol][1] v2.0 for Web Components and
 * Polymer.
 *
 * Communicates over stdin/stdout.
 *
 * [1]: https://github.com/Microsoft/language-server-protocol
 */
const path = require("path");
const fs_url_loader_1 = require("polymer-analyzer/lib/url-loader/fs-url-loader");
const package_url_resolver_1 = require("polymer-analyzer/lib/url-loader/package-url-resolver");
const warning_1 = require("polymer-analyzer/lib/warning/warning");
const url = require("url");
const util = require("util");
const vscode_languageserver_1 = require("vscode-languageserver");
const local_editor_service_1 = require("./local-editor-service");
const fileUrl = require('file-url');
// Create a connection for the server. Communicate using stdio.
let connection = vscode_languageserver_1.createConnection(process.stdin, process.stdout);
// The settings have changed. Is sent on server activation as well.
connection.onDidChangeConfiguration((change) => {
    let settings = change.settings;
    // TODO(rictic): use settings for real
    settings.polymerVscodePlugin;
});
let editorService = null;
// Create a simple text document manager. The text document manager
// supports full document sync only
// TODO(rictic): for speed, sync diffs instead.
let documents = new vscode_languageserver_1.TextDocuments();
// Make the text document manager listen on the connection
// for open, change and close text document events
documents.listen(connection);
// After the server has started the client sends an initilize request. The
// server receives in the passed params the rootPath of the workspace plus the
// client capabilites.
let workspaceUri = null;
function getWorkspaceUri(rootUri, rootPath) {
    if (rootUri) {
        return url.parse(rootUri);
    }
    if (rootPath) {
        return url.parse(fileUrl(rootPath));
    }
    return null;
}
function fileUrlToAbsolutePath(fileUrl) {
    const path = decodeURIComponent(fileUrl.pathname);
    if (process.platform === 'win32' && path[0] === '/') {
        return path.slice(1);
    }
    return path;
}
connection.onInitialize((params) => {
    let maybeWorkspaceUri = getWorkspaceUri(params.rootUri, params.rootPath);
    // Leave workspaceUri unset if we're initialized in a way we can't handle.
    if (!maybeWorkspaceUri || maybeWorkspaceUri.protocol !== 'file:') {
        return { capabilities: {} };
    }
    workspaceUri = maybeWorkspaceUri;
    const workspacePath = fileUrlToAbsolutePath(workspaceUri);
    const polymerJsonPath = path.join(workspacePath, 'polymer.json');
    editorService = new local_editor_service_1.LocalEditorService({
        urlLoader: new fs_url_loader_1.FSUrlLoader(workspacePath),
        urlResolver: new package_url_resolver_1.PackageUrlResolver(), polymerJsonPath
    });
    documents.all().forEach(d => scanDocument(d));
    return {
        capabilities: {
            // Tell the client that the server works in FULL text document sync mode
            textDocumentSync: documents.syncKind,
            // Tell the client that the server support code complete
            completionProvider: { resolveProvider: false },
            hoverProvider: true,
            definitionProvider: true,
        }
    };
});
// The content of a text document has changed. This event is emitted
// when the text document is first opened or when its content has changed.
documents.onDidChangeContent((change) => {
    scanDocument(change.document, connection);
});
connection.onHover((textPosition) => __awaiter(this, void 0, void 0, function* () {
    return handleErrors(getDocsForHover(textPosition), undefined);
}));
function getDocsForHover(textPosition) {
    return __awaiter(this, void 0, void 0, function* () {
        const localPath = getWorkspacePathToFile(textPosition.textDocument);
        if (localPath && editorService) {
            const documentation = yield editorService.getDocumentationAtPosition(localPath, convertPosition(textPosition.position));
            if (documentation) {
                return { contents: documentation };
            }
        }
    });
}
connection.onDefinition((textPosition) => __awaiter(this, void 0, void 0, function* () {
    return handleErrors(getDefinition(textPosition), undefined);
}));
function getDefinition(textPosition) {
    return __awaiter(this, void 0, void 0, function* () {
        const localPath = getWorkspacePathToFile(textPosition.textDocument);
        if (localPath && editorService) {
            const location = yield editorService.getDefinitionForFeatureAtPosition(localPath, convertPosition(textPosition.position));
            if (location && location.file) {
                let definition = {
                    uri: getUriForLocalPath(location.file),
                    range: convertRange(location)
                };
                return definition;
            }
        }
    });
}
// This handler provides the initial list of the completion items.
connection.onCompletion((textPosition) => __awaiter(this, void 0, void 0, function* () {
    return handleErrors(autoComplete(textPosition), { isIncomplete: true, items: [] });
}));
function autoComplete(textPosition) {
    return __awaiter(this, void 0, void 0, function* () {
        const localPath = getWorkspacePathToFile(textPosition.textDocument);
        if (!localPath || !editorService) {
            return { isIncomplete: true, items: [] };
        }
        const completions = yield editorService.getTypeaheadCompletionsAtPosition(localPath, convertPosition(textPosition.position));
        if (!completions) {
            return { isIncomplete: false, items: [] };
        }
        if (completions.kind === 'element-tags') {
            return {
                isIncomplete: false,
                items: completions.elements.map(c => {
                    return {
                        label: `<${c.tagname}>`,
                        kind: vscode_languageserver_1.CompletionItemKind.Class,
                        documentation: c.description,
                        insertText: c.expandTo
                    };
                }),
            };
        }
        else if (completions.kind === 'attributes') {
            return {
                isIncomplete: false,
                items: completions.attributes.map(a => {
                    const item = {
                        label: a.name,
                        kind: vscode_languageserver_1.CompletionItemKind.Field,
                        documentation: a.description,
                        sortText: a.sortKey
                    };
                    if (a.type) {
                        item.detail = `{${a.type}}`;
                    }
                    if (a.inheritedFrom) {
                        if (item.detail) {
                            item.detail = `${item.detail} ⊃ ${a.inheritedFrom}`;
                        }
                        else {
                            item.detail = `⊃ ${a.inheritedFrom}`;
                        }
                    }
                    return item;
                }),
            };
        }
        return { isIncomplete: false, items: [] };
    });
}
;
function getWorkspacePathToFile(doc) {
    const docUrl = url.parse(doc.uri);
    if (!workspaceUri || !workspaceUri.pathname || !docUrl.pathname) {
        return undefined;
    }
    const workspacePath = fileUrlToAbsolutePath(workspaceUri);
    const docPath = fileUrlToAbsolutePath(docUrl);
    return path.relative(workspacePath, docPath);
}
function getUriForLocalPath(localPath) {
    if (!workspaceUri) {
        throw new Error(`Tried to get the URI of ${localPath} without knowing the workspaceUri!?`);
    }
    const workspacePath = fileUrlToAbsolutePath(workspaceUri);
    const absolutePath = path.join(workspacePath, localPath);
    return fileUrl(absolutePath);
}
function convertPosition(position) {
    return { line: position.line, column: position.character };
}
function convertRange(range) {
    return {
        start: { line: range.start.line, character: range.start.column },
        end: { line: range.end.line, character: range.end.column }
    };
}
function convertSeverity(severity) {
    switch (severity) {
        case warning_1.Severity.ERROR:
            return vscode_languageserver_1.DiagnosticSeverity.Error;
        case warning_1.Severity.WARNING:
            return vscode_languageserver_1.DiagnosticSeverity.Warning;
        case warning_1.Severity.INFO:
            return vscode_languageserver_1.DiagnosticSeverity.Information;
        default:
            throw new Error(`This should never happen. Got a severity of ${severity}`);
    }
}
function scanDocument(document, connection) {
    return __awaiter(this, void 0, void 0, function* () {
        return handleErrors(_scanDocument(document, connection), undefined);
    });
}
function _scanDocument(document, connection) {
    return __awaiter(this, void 0, void 0, function* () {
        if (editorService) {
            const localPath = getWorkspacePathToFile(document);
            if (!localPath) {
                return;
            }
            editorService.fileChanged(localPath, document.getText());
            if (connection) {
                const diagnostics = [];
                const warnings = yield editorService.getWarningsForFile(localPath);
                for (const warning of warnings) {
                    diagnostics.push({
                        code: warning.code,
                        message: warning.message,
                        range: convertRange(warning.sourceRange),
                        source: 'polymer-ide',
                        severity: convertSeverity(warning.severity),
                    });
                }
                connection.sendDiagnostics({ diagnostics, uri: document.uri });
            }
        }
    });
}
;
function handleErrors(promise, fallbackValue) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return yield promise;
        }
        catch (err) {
            // Ignore WarningCarryingExceptions, they're expected, and made visible
            //   to the user in a useful way. All other exceptions should be logged
            //   if possible.
            if (connection && !(err instanceof warning_1.WarningCarryingException)) {
                connection.console.warn(err.stack || err.message || err);
            }
            return fallbackValue;
        }
    });
}
/**
 * A useful function for debugging. Logs through the connect to the editor
 * so that the logs are visible.
 */
function log(val) {
    if (!connection) {
        return;
    }
    if (typeof val !== 'string') {
        val = util.inspect(val);
    }
    connection.console.log(val);
}
if (Math.random() > 10000) {
    // Reference log here to ensure that typescript doesn't warn about it being
    // unused.
    // At any given time there may not be any uses of it, but it is useful to have
    // around when debugging.
    log;
}
// Listen on the connection
connection.listen();
//# sourceMappingURL=polymer-language-server.js.map