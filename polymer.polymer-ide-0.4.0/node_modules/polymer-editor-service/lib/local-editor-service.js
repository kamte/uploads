"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @license
 * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const dom5 = require("dom5");
const polymer_analyzer_1 = require("polymer-analyzer");
const html_document_1 = require("polymer-analyzer/lib/html/html-document");
const polymer_linter_1 = require("polymer-linter");
const polymer_project_config_1 = require("polymer-project-config");
const ast_from_source_position_1 = require("./ast-from-source-position");
const editor_service_1 = require("./editor-service");
class LocalEditorService extends editor_service_1.EditorService {
    constructor(options) {
        super();
        this._analyzer = new polymer_analyzer_1.Analyzer(options);
        // TODO(rictic): watch for changes of polymer.json
        let rules = new Set();
        if (options.polymerJsonPath) {
            let config = null;
            try {
                config = polymer_project_config_1.ProjectConfig.loadConfigFromFile(options.polymerJsonPath);
            }
            catch (_) {
                // TODO(rictic): warn about the error
            }
            if (config && config.lint && config.lint.rules) {
                try {
                    rules = polymer_linter_1.registry.getRules(config.lint.rules);
                }
                catch (_) {
                    // TODO(rictic): warn about the bad rule
                }
            }
        }
        this._linter = new polymer_linter_1.Linter(rules, this._analyzer);
    }
    fileChanged(localPath, contents) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._analyzer.analyze(localPath, contents);
        });
    }
    getDocumentationAtPosition(localPath, position) {
        return __awaiter(this, void 0, void 0, function* () {
            const feature = yield this._getFeatureAt(localPath, position);
            if (!feature) {
                return;
            }
            if (isProperty(feature)) {
                if (feature.type) {
                    return `{${feature.type}} ${feature.description}`;
                }
            }
            return feature.description;
        });
    }
    getDefinitionForFeatureAtPosition(localPath, position) {
        return __awaiter(this, void 0, void 0, function* () {
            const feature = yield this._getFeatureAt(localPath, position);
            if (!feature) {
                return;
            }
            return feature.sourceRange;
        });
    }
    getReferencesForFeatureAtPosition(localPath, position) {
        return __awaiter(this, void 0, void 0, function* () {
            const document = yield this._analyzer.analyze(localPath);
            const location = yield this._getLocationResult(document, position);
            if (!location) {
                return;
            }
            if (location.kind === 'tagName') {
                return Array
                    .from(document.getById('element-reference', location.element.tagName, { externalPackages: true, imported: true }))
                    .map(e => e.sourceRange);
            }
        });
    }
    getTypeaheadCompletionsAtPosition(localPath, position) {
        return __awaiter(this, void 0, void 0, function* () {
            const document = yield this._analyzer.analyze(localPath);
            const location = yield this._getLocationResult(document, position);
            if (!location) {
                return;
            }
            if (location.kind === 'tagName' || location.kind === 'text') {
                const elements = Array
                    .from(document.getByKind('element', { externalPackages: true, imported: true }))
                    .filter(e => e.tagName);
                return {
                    kind: 'element-tags',
                    elements: elements.map(e => {
                        const attributesSpace = e.attributes.length > 0 ? ' ' : '';
                        return {
                            tagname: e.tagName,
                            description: e.description,
                            expandTo: location.kind === 'text' ?
                                `<${e.tagName}${attributesSpace}></${e.tagName}>` :
                                undefined,
                            expandToSnippet: location.kind === 'text' ?
                                this._generateAutoCompletionForElement(e) :
                                undefined
                        };
                    })
                };
            }
            if (location.kind === 'attributeValue') {
                const domModule = this.getAncestorDomModuleForElement(document, location.element);
                if (!domModule || !domModule.id)
                    return;
                const outerElement = document.getOnlyAtId('element', domModule.id, { imported: true, externalPackages: true });
                if (!outerElement)
                    return;
                const sortPrefixes = this._createSortPrefixes(outerElement);
                const innerElement = document.getOnlyAtId('element', location.element.nodeName, { imported: true, externalPackages: true });
                if (!innerElement)
                    return;
                const innerAttribute = innerElement.attributes.find((value) => value.name === location.attribute);
                if (!innerAttribute)
                    return;
                const attributeValue = dom5.getAttribute(location.element, innerAttribute.name);
                const hasDelimeters = /^\s*(\{\{|\[\[)/.test(attributeValue);
                return {
                    kind: 'attribute-values',
                    attributes: outerElement.properties.map(p => {
                        const sortKey = (sortPrefixes.get(p.inheritedFrom) || `ddd-`) + p.name;
                        let autocompletion;
                        if (attributeValue && hasDelimeters) {
                            autocompletion = p.name;
                        }
                        else {
                            if (innerAttribute.changeEvent) {
                                autocompletion = `{{${p.name}}}`;
                            }
                            else {
                                autocompletion = `[[${p.name}]]`;
                            }
                        }
                        return {
                            name: p.name,
                            description: p.description || '',
                            type: p.type,
                            autocompletion: autocompletion,
                            inheritedFrom: p.inheritedFrom, sortKey
                        };
                    })
                };
            }
            if (location.kind === 'attribute') {
                const elements = document.getById('element', location.element.nodeName, { externalPackages: true, imported: true });
                let attributes = [];
                for (const element of elements) {
                    const sortPrefixes = this._createSortPrefixes(element);
                    const elementAttributes = element.attributes.map(p => {
                        const sortKey = (sortPrefixes.get(p.inheritedFrom) || `ddd-`) + p.name;
                        return {
                            name: p.name,
                            description: p.description || '',
                            type: p.type,
                            inheritedFrom: p.inheritedFrom, sortKey
                        };
                    });
                    const eventAttributes = element.events.map((e) => {
                        const postfix = sortPrefixes.get(e.inheritedFrom) || 'ddd-';
                        const sortKey = `eee-${postfix}on-${e.name}`;
                        return {
                            name: `on-${e.name}`,
                            description: e.description || '',
                            type: e.type || 'CustomEvent',
                            inheritedFrom: e.inheritedFrom, sortKey
                        };
                    });
                    attributes =
                        attributes.concat(elementAttributes).concat(eventAttributes);
                }
                return { kind: 'attributes', attributes };
            }
            ;
        });
    }
    _createSortPrefixes(element) {
        // A map from the inheritedFrom to a sort prefix. Note that
        // `undefined` is a legal value for inheritedFrom.
        const sortPrefixes = new Map();
        // Not inherited, that means local! Sort it early.
        sortPrefixes.set(undefined, 'aaa-');
        if (element.superClass) {
            sortPrefixes.set(element.superClass, 'bbb-');
        }
        if (element.extends) {
            sortPrefixes.set(element.extends, 'ccc-');
        }
        return sortPrefixes;
    }
    _generateAutoCompletionForElement(e) {
        let autocompletion = `<${e.tagName}`;
        let tabindex = 1;
        if (e.attributes.length) {
            autocompletion += ` $${tabindex++}`;
        }
        autocompletion += `>`;
        if (e.slots.length === 1 && !e.slots[0].name) {
            autocompletion += `$${tabindex++}`;
        }
        else {
            for (const slot of e.slots) {
                const tagTabIndex = tabindex++;
                const slotAttribute = slot.name ? ` slot="${slot.name}"` : '';
                autocompletion += '\n\t<${' + tagTabIndex + ':div}' + slotAttribute +
                    '>$' + tabindex++ + '</${' + tagTabIndex + ':div}>';
            }
            if (e.slots.length) {
                autocompletion += '\n';
            }
        }
        return autocompletion + `</${e.tagName}>$0`;
    }
    getAncestorDomModuleForElement(document, element) {
        const parsedDocument = document.parsedDocument;
        if (!(parsedDocument instanceof html_document_1.ParsedHtmlDocument)) {
            return;
        }
        const elementSourcePosition = parsedDocument.sourceRangeForNode(element).start;
        const domModules = document.getByKind('dom-module', { imported: false });
        for (const domModule of domModules) {
            if (ast_from_source_position_1.isPositionInsideRange(elementSourcePosition, parsedDocument.sourceRangeForNode(domModule.node))) {
                return domModule;
            }
        }
    }
    getWarningsForFile(localPath) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._linter.lint([localPath]);
        });
    }
    _clearCaches() {
        return __awaiter(this, void 0, void 0, function* () {
            this._analyzer.clearCaches();
        });
    }
    _getFeatureAt(localPath, position) {
        return __awaiter(this, void 0, void 0, function* () {
            const document = yield this._analyzer.analyze(localPath);
            const location = yield this._getLocationResult(document, position);
            if (!location) {
                return;
            }
            if (location.kind === 'tagName') {
                return document.getOnlyAtId('element', location.element.nodeName, { imported: true, externalPackages: true });
            }
            else if (location.kind === 'attribute') {
                const elements = document.getById('element', location.element.nodeName, { imported: true, externalPackages: true });
                if (elements.size === 0) {
                    return;
                }
                return concatMap(elements, (el) => el.attributes)
                    .find(at => at.name === location.attribute);
            }
        });
    }
    _getLocationResult(document, position) {
        return __awaiter(this, void 0, void 0, function* () {
            const parsedDocument = document.parsedDocument;
            if (!(parsedDocument instanceof html_document_1.ParsedHtmlDocument)) {
                return;
            }
            return ast_from_source_position_1.getLocationInfoForPosition(parsedDocument, position);
        });
    }
}
exports.LocalEditorService = LocalEditorService;
function isProperty(d) {
    return 'type' in d;
}
function concatMap(inputs, f) {
    let results = [];
    for (const input of inputs) {
        results = results.concat(f(input));
    }
    return results;
}
//# sourceMappingURL=local-editor-service.js.map